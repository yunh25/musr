"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const nock_1 = __importDefault(require("nock"));
const node_1 = require("./node");
describe("Node timeout tests", () => {
    it("should timeout when request takes too long", async () => {
        // Mock a slow endpoint
        (0, nock_1.default)("https://in.logs.betterstack.com")
            .post("/")
            .delay(2000) // 2 second delay
            .reply(200);
        const logger = new node_1.Node("test-token", {
            timeout: 1000, // 1 second timeout
            syncMax: 1,
            ignoreExceptions: false,
        });
        // This should timeout
        await expect(logger.log("Test message")).rejects.toThrow("Request timeout after 1000ms");
    });
    it("should complete successfully when request is within timeout", async () => {
        // Mock a normal endpoint
        (0, nock_1.default)("https://in.logs.betterstack.com")
            .post("/")
            .delay(100) // 100ms delay
            .reply(200);
        const logger = new node_1.Node("test-token", {
            timeout: 1000, // 1 second timeout
            syncMax: 1,
        });
        // This should succeed
        const result = await logger.log("Test message");
        expect(result).toHaveProperty("message", "Test message");
    });
    it("should work without timeout when timeout is 0", async () => {
        // Mock a slow endpoint
        (0, nock_1.default)("https://in.logs.betterstack.com")
            .post("/")
            .delay(2000) // 2 second delay
            .reply(200);
        const logger = new node_1.Node("test-token", {
            timeout: 0, // No timeout
            syncMax: 1,
        });
        // This should complete despite the delay
        const result = await logger.log("Test message");
        expect(result).toHaveProperty("message", "Test message");
    });
});
describe("Queue limit tests", () => {
    it("should drop logs when queue limit is exceeded", async () => {
        // Mock a very slow endpoint that will cause queue buildup
        (0, nock_1.default)("https://in.logs.betterstack.com")
            .post("/")
            .times(10)
            .delay(5000) // 5 second delay to simulate stuck requests
            .reply(200);
        const logger = new node_1.Node("test-token", {
            syncMax: 2, // Only 2 concurrent requests
            syncQueuedMax: 3, // Only 3 can be queued
            ignoreExceptions: true, // Ignore exceptions so we can check dropped count
            batchInterval: 0, // Send immediately
            batchSize: 1, // One log per batch
        });
        // Send 10 logs rapidly
        const promises = [];
        for (let i = 0; i < 10; i++) {
            promises.push(logger.log(`Message ${i}`).catch(() => { }));
        }
        // Wait a bit for queue processing
        await new Promise(resolve => setTimeout(resolve, 100));
        // Check that some logs were dropped
        // 2 in flight + 3 queued = 5 total, so 5 should be dropped
        expect(logger.dropped).toBeGreaterThan(0);
        expect(logger.dropped).toBeLessThanOrEqual(5);
    });
    it("should not drop logs when queue limit is disabled", async () => {
        // Mock endpoint
        (0, nock_1.default)("https://in.logs.betterstack.com")
            .post("/")
            .times(10)
            .reply(200);
        const logger = new node_1.Node("test-token", {
            syncMax: 2,
            syncQueuedMax: 0, // Unlimited queue
            batchInterval: 0,
            batchSize: 1,
        });
        // Send 10 logs
        const promises = [];
        for (let i = 0; i < 10; i++) {
            promises.push(logger.log(`Message ${i}`));
        }
        await Promise.all(promises);
        // No logs should be dropped
        expect(logger.dropped).toBe(0);
        expect(logger.synced).toBe(10);
    });
});
//# sourceMappingURL=timeout.test.js.map