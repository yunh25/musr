import { BaseMessage } from "./base";
import { CloudToGlassesMessageType } from "../message-types";
import { UserSession } from "../user-session";
import { Layout } from "../layouts";
/**
 * Connection acknowledgment to glasses
 */
export interface ConnectionAck extends BaseMessage {
    type: CloudToGlassesMessageType.CONNECTION_ACK;
    userSession: Partial<UserSession>;
    sessionId: string;
}
/**
 * Connection error to glasses
 */
export interface ConnectionError extends BaseMessage {
    type: CloudToGlassesMessageType.CONNECTION_ERROR;
    code?: string;
    message: string;
}
/**
 * Authentication error to glasses
 */
export interface AuthError extends BaseMessage {
    type: CloudToGlassesMessageType.AUTH_ERROR;
    message: string;
}
/**
 * Display update to glasses
 */
export interface DisplayEvent extends BaseMessage {
    type: CloudToGlassesMessageType.DISPLAY_EVENT;
    layout: Layout;
    durationMs?: number;
}
/**
 * App state change to glasses
 */
export interface AppStateChange extends BaseMessage {
    type: CloudToGlassesMessageType.APP_STATE_CHANGE;
    userSession: Partial<UserSession>;
    error?: string;
}
/**
 * Microphone state change to glasses
 */
export interface MicrophoneStateChange extends BaseMessage {
    type: CloudToGlassesMessageType.MICROPHONE_STATE_CHANGE;
    userSession: Partial<UserSession>;
    isMicrophoneEnabled: boolean;
    requiredData: Array<"pcm" | "transcription" | "pcm_or_transcription">;
    bypassVad?: boolean;
}
/**
 * Photo request to glasses
 */
export interface PhotoRequestToGlasses extends BaseMessage {
    type: CloudToGlassesMessageType.PHOTO_REQUEST;
    userSession: Partial<UserSession>;
    requestId: string;
    appId: string;
    saveToGallery?: boolean;
    webhookUrl?: string;
    /** Desired capture size to guide device resolution selection */
    size?: "small" | "medium" | "large";
}
/**
 * Settings update to glasses
 */
export interface SettingsUpdate extends BaseMessage {
    type: CloudToGlassesMessageType.SETTINGS_UPDATE;
    sessionId: string;
    settings: {
        useOnboardMic: boolean;
        contextualDashboard: boolean;
        metricSystemEnabled: boolean;
        headUpAngle: number;
        brightness: number;
        autoBrightness: boolean;
        sensingEnabled: boolean;
        alwaysOnStatusBar: boolean;
        bypassVad: boolean;
        bypassAudioEncoding: boolean;
    };
}
/**
 * Start RTMP stream command to glasses
 */
export interface StartRtmpStream extends BaseMessage {
    type: CloudToGlassesMessageType.START_RTMP_STREAM;
    rtmpUrl: string;
    appId: string;
    streamId?: string;
    video?: any;
    audio?: any;
    stream?: any;
}
/**
 * Stop RTMP stream command to glasses
 */
export interface StopRtmpStream extends BaseMessage {
    type: CloudToGlassesMessageType.STOP_RTMP_STREAM;
    appId: string;
    streamId?: string;
}
/**
 * Keep RTMP stream alive command to glasses
 */
export interface KeepRtmpStreamAlive extends BaseMessage {
    type: CloudToGlassesMessageType.KEEP_RTMP_STREAM_ALIVE;
    streamId: string;
    ackId: string;
}
/**
 * Sets the continuous location update tier on the device.
 */
export interface SetLocationTier extends BaseMessage {
    type: CloudToGlassesMessageType.SET_LOCATION_TIER;
    tier: "realtime" | "high" | "tenMeters" | "hundredMeters" | "kilometer" | "threeKilometers" | "reduced" | "standard";
}
/**
 * Requests a single, on-demand location fix from the device.
 */
export interface RequestSingleLocation extends BaseMessage {
    type: CloudToGlassesMessageType.REQUEST_SINGLE_LOCATION;
    accuracy: string;
    correlationId: string;
}
/**
 * Audio play request to glasses
 */
export interface AudioPlayRequestToGlasses extends BaseMessage {
    type: CloudToGlassesMessageType.AUDIO_PLAY_REQUEST;
    userSession: Partial<UserSession>;
    requestId: string;
    appId: string;
    audioUrl: string;
    volume?: number;
    stopOtherAudio?: boolean;
}
/**
 * Audio stop request to glasses
 */
export interface AudioStopRequestToGlasses extends BaseMessage {
    type: CloudToGlassesMessageType.AUDIO_STOP_REQUEST;
    userSession: Partial<UserSession>;
    appId: string;
}
/**
 * Union type for all messages from cloud to glasses
 */
export type CloudToGlassesMessage = ConnectionAck | ConnectionError | AuthError | DisplayEvent | AppStateChange | MicrophoneStateChange | PhotoRequestToGlasses | AudioPlayRequestToGlasses | AudioStopRequestToGlasses | SettingsUpdate | StartRtmpStream | StopRtmpStream | KeepRtmpStreamAlive | SetLocationTier | RequestSingleLocation;
export declare function isResponse(message: CloudToGlassesMessage): boolean;
export declare function isUpdate(message: CloudToGlassesMessage): boolean;
export declare function isConnectionAck(message: CloudToGlassesMessage): message is ConnectionAck;
export declare function isConnectionError(message: CloudToGlassesMessage): message is ConnectionError;
export declare function isAuthError(message: CloudToGlassesMessage): message is AuthError;
export declare function isDisplayEvent(message: CloudToGlassesMessage): message is DisplayEvent;
export declare function isAppStateChange(message: CloudToGlassesMessage): message is AppStateChange;
export declare function isMicrophoneStateChange(message: CloudToGlassesMessage): message is MicrophoneStateChange;
export declare function isPhotoRequest(message: CloudToGlassesMessage): message is PhotoRequestToGlasses;
export declare function isSettingsUpdate(message: CloudToGlassesMessage): message is SettingsUpdate;
export declare function isStartRtmpStream(message: CloudToGlassesMessage): message is StartRtmpStream;
export declare function isStopRtmpStream(message: CloudToGlassesMessage): message is StopRtmpStream;
export declare function isKeepRtmpStreamAlive(message: CloudToGlassesMessage): message is KeepRtmpStreamAlive;
export declare function isAudioPlayRequestToGlasses(message: CloudToGlassesMessage): message is AudioPlayRequestToGlasses;
export declare function isAudioStopRequestToGlasses(message: CloudToGlassesMessage): message is AudioStopRequestToGlasses;
//# sourceMappingURL=cloud-to-glasses.d.ts.map