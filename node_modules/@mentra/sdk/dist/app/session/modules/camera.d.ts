/**
 * 📷 Camera Module
 *
 * Unified camera functionality for App Sessions.
 * Handles both photo requests and RTMP streaming from connected glasses.
 */
import { PhotoData, RtmpStreamStatus, ManagedStreamStatus, StreamStatusCheckResponse } from "../../../types";
import { VideoConfig, AudioConfig, StreamConfig, StreamStatusHandler } from "../../../types/rtmp-stream";
import { Logger } from "pino";
import { ManagedStreamOptions, ManagedStreamResult } from "./camera-managed-extension";
/**
 * Options for photo requests
 */
export interface PhotoRequestOptions {
    /** Whether to save the photo to the device gallery */
    saveToGallery?: boolean;
    /** Custom webhook URL to override the TPA's default webhookUrl */
    customWebhookUrl?: string;
    /**
     * Desired photo size.
     * - small: lowest resolution, faster capture/transfer
     * - medium: balanced default
     * - large: highest available resolution on device
     */
    size?: "small" | "medium" | "large";
}
/**
 * Configuration options for an RTMP stream
 */
export interface RtmpStreamOptions {
    /** The RTMP URL to stream to (e.g., rtmp://server.example.com/live/stream-key) */
    rtmpUrl: string;
    /** Optional video configuration settings */
    video?: VideoConfig;
    /** Optional audio configuration settings */
    audio?: AudioConfig;
    /** Optional stream configuration settings */
    stream?: StreamConfig;
}
/**
 * 📷 Camera Module Implementation
 *
 * Unified camera management for App Sessions.
 * Provides methods for:
 * - 📸 Requesting photos from glasses
 * - 📹 Starting/stopping RTMP streams
 * - 🔍 Monitoring photo and stream status
 * - 🧹 Cleanup and cancellation
 *
 * @example
 * ```typescript
 * // Request a photo
 * const photoData = await session.camera.requestPhoto({ saveToGallery: true });
 *
 * // Start streaming
 * await session.camera.startStream({ rtmpUrl: 'rtmp://example.com/live/key' });
 *
 * // Monitor stream status
 * session.camera.onStreamStatus((status) => {
 *   console.log('Stream status:', status.status);
 * });
 *
 * // Stop streaming
 * await session.camera.stopStream();
 * ```
 */
export declare class CameraModule {
    private send;
    private packageName;
    private sessionId;
    private session?;
    private logger;
    /** Map to store pending photo request promises */
    private pendingPhotoRequests;
    private isStreaming;
    private currentStreamUrl?;
    private currentStreamState?;
    private managedExtension;
    /**
     * Create a new CameraModule
     *
     * @param packageName - The App package name
     * @param sessionId - The current session ID
     * @param send - Function to send messages to the cloud
     * @param session - Reference to the parent AppSession (optional)
     * @param logger - Logger instance for debugging
     */
    constructor(packageName: string, sessionId: string, send: (message: any) => void, session?: any, logger?: Logger);
    /**
     * 📸 Request a photo from the connected glasses
     *
     * @param options - Optional configuration for the photo request
     * @returns Promise that resolves with the actual photo data
     *
     * @example
     * ```typescript
     * // Request a photo
     * const photo = await session.camera.requestPhoto();
     *
     * // Request a photo with custom webhook URL
     * const photo = await session.camera.requestPhoto({
     *   customWebhookUrl: 'https://my-custom-endpoint.com/photo-upload'
     * });
     * ```
     */
    requestPhoto(options?: PhotoRequestOptions): Promise<PhotoData>;
    /**
     * 📥 Handle photo received from /photo-upload endpoint
     *
     * This method is called internally when a photo response is received.
     * It resolves the corresponding pending promise with the photo data.
     *
     * @param photoData - The photo data received
     * @internal This method is used internally by AppSession
     */
    handlePhotoReceived(photoData: PhotoData): void;
    /**
     * 🔍 Check if there's a pending photo request for the given request ID
     *
     * @param requestId - The request ID to check
     * @returns true if there's a pending request
     */
    hasPhotoPendingRequest(requestId: string): boolean;
    /**
     * 📊 Get the number of pending photo requests
     *
     * @returns Number of pending photo requests
     */
    getPhotoPendingRequestCount(): number;
    /**
     * 📋 Get all pending photo request IDs
     *
     * @returns Array of pending request IDs
     */
    getPhotoPendingRequestIds(): string[];
    /**
     * ❌ Cancel a pending photo request
     *
     * @param requestId - The request ID to cancel
     * @returns true if the request was cancelled, false if it wasn't found
     */
    cancelPhotoRequest(requestId: string): boolean;
    /**
     * 🧹 Cancel all pending photo requests
     *
     * @returns Number of requests that were cancelled
     */
    cancelAllPhotoRequests(): number;
    /**
     * 📹 Start an RTMP stream to the specified URL
     *
     * @param options - Configuration options for the stream
     * @returns Promise that resolves when the stream request is sent (not when streaming begins)
     *
     * @example
     * ```typescript
     * await session.camera.startStream({
     *   rtmpUrl: 'rtmp://live.example.com/stream/key',
     *   video: { resolution: '1920x1080', bitrate: 5000 },
     *   audio: { bitrate: 128 }
     * });
     * ```
     */
    startStream(options: RtmpStreamOptions): Promise<void>;
    /**
     * 🛑 Stop the current RTMP stream
     *
     * @returns Promise that resolves when the stop request is sent
     *
     * @example
     * ```typescript
     * await session.camera.stopStream();
     * ```
     */
    stopStream(): Promise<void>;
    /**
     * 🔍 Check if currently streaming
     *
     * @returns True if a stream is active or initializing
     */
    isCurrentlyStreaming(): boolean;
    /**
     * 📍 Get the URL of the current stream (if any)
     *
     * @returns The RTMP URL of the current stream, or undefined if not streaming
     */
    getCurrentStreamUrl(): string | undefined;
    /**
     * 📊 Get the current stream status
     *
     * @returns The current stream status, or undefined if not available
     */
    getStreamStatus(): RtmpStreamStatus | undefined;
    /**
     * 📺 Subscribe to RTMP stream status updates
     * This uses the standard stream subscription mechanism
     */
    subscribeToStreamStatusUpdates(): void;
    /**
     * 📺 Unsubscribe from RTMP stream status updates
     */
    unsubscribeFromStreamStatusUpdates(): void;
    /**
     * 👂 Listen for stream status updates using the standard event system
     * @param handler - Function to call when stream status changes
     * @returns Cleanup function to remove the handler
     *
     * @example
     * ```typescript
     * const cleanup = session.camera.onStreamStatus((status) => {
     *   console.log('Stream status:', status.status);
     *   if (status.status === 'error') {
     *     console.error('Stream error:', status.errorDetails);
     *   }
     * });
     *
     * // Later, cleanup the listener
     * cleanup();
     * ```
     */
    onStreamStatus(handler: StreamStatusHandler): () => void;
    /**
     * 🔄 Update internal stream state based on a status message
     * For internal use by AppSession
     * @param message - The status message from the cloud
     * @internal This method is used internally by AppSession
     */
    updateStreamState(message: any): void;
    /**
     * 📹 Start a managed stream
     *
     * The cloud handles the RTMP endpoint and returns HLS/DASH URLs for viewing.
     * Multiple apps can consume the same managed stream simultaneously.
     *
     * @param options - Configuration options for the managed stream
     * @returns Promise that resolves with viewing URLs when the stream is ready
     *
     * @example
     * ```typescript
     * const urls = await session.camera.startManagedStream({
     *   quality: '720p',
     *   enableWebRTC: true
     * });
     * console.log('HLS URL:', urls.hlsUrl);
     * ```
     */
    startManagedStream(options?: ManagedStreamOptions): Promise<ManagedStreamResult>;
    /**
     * 🛑 Stop the current managed stream
     *
     * This will stop streaming for this app only. If other apps are consuming
     * the same managed stream, it will continue for them.
     *
     * @returns Promise that resolves when the stop request is sent
     */
    stopManagedStream(): Promise<void>;
    /**
     * 🔔 Register a handler for managed stream status updates
     *
     * @param handler - Function to call when stream status changes
     * @returns Cleanup function to unregister the handler
     */
    onManagedStreamStatus(handler: (status: ManagedStreamStatus) => void): () => void;
    /**
     * 📊 Check if currently managed streaming
     *
     * @returns true if a managed stream is active
     */
    isManagedStreamActive(): boolean;
    /**
     * 🔗 Get current managed stream URLs
     *
     * @returns Current stream URLs or undefined if not streaming
     */
    getManagedStreamUrls(): ManagedStreamResult | undefined;
    /**
     * 🔍 Check for any existing streams (managed or unmanaged) for the current user
     *
     * This method checks if there's already an active stream for the current user,
     * which is useful to avoid conflicts and to reconnect to existing streams.
     *
     * @returns Promise that resolves with stream information if a stream exists
     *
     * @example
     * ```typescript
     * const streamInfo = await session.camera.checkExistingStream();
     * if (streamInfo.hasActiveStream) {
     *   console.log('Stream type:', streamInfo.streamInfo?.type);
     *   if (streamInfo.streamInfo?.type === 'managed') {
     *     console.log('HLS URL:', streamInfo.streamInfo.hlsUrl);
     *   } else {
     *     console.log('RTMP URL:', streamInfo.streamInfo.rtmpUrl);
     *   }
     * }
     * ```
     */
    checkExistingStream(): Promise<{
        hasActiveStream: boolean;
        streamInfo?: {
            type: "managed" | "unmanaged";
            streamId: string;
            status: string;
            createdAt: Date;
            hlsUrl?: string;
            dashUrl?: string;
            webrtcUrl?: string;
            previewUrl?: string;
            thumbnailUrl?: string;
            activeViewers?: number;
            rtmpUrl?: string;
            requestingAppId?: string;
        };
    }>;
    /**
     * Handle incoming stream status check response
     * @internal
     */
    handleStreamCheckResponse(response: StreamStatusCheckResponse): void;
    /**
     * Handle incoming managed stream status messages
     * @internal
     */
    handleManagedStreamStatus(message: ManagedStreamStatus): void;
    /**
     * 🔧 Update the session ID (used when reconnecting)
     *
     * @param newSessionId - The new session ID
     * @internal This method is used internally by AppSession
     */
    updateSessionId(newSessionId: string): void;
    /**
     * 🧹 Cancel all pending requests and clean up resources
     *
     * @returns Object with counts of cancelled requests
     */
    cancelAllRequests(): {
        photoRequests: number;
    };
}
export { VideoConfig, AudioConfig, StreamConfig, StreamStatusHandler };
//# sourceMappingURL=camera.d.ts.map