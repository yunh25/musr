/**
 * üì∑ Camera Module Managed Streaming Extension
 *
 * Extends the camera module with managed streaming capabilities.
 * Apps can request managed streams and receive HLS/DASH URLs without managing RTMP endpoints.
 */
import { ManagedStreamStatus, StreamStatusCheckResponse, RestreamDestination } from "../../../types";
import { VideoConfig, AudioConfig, StreamConfig } from "../../../types/rtmp-stream";
import { Logger } from "pino";
/**
 * Configuration options for a managed stream
 */
export interface ManagedStreamOptions {
    /** Stream quality preset */
    quality?: "720p" | "1080p";
    /** Enable WebRTC for ultra-low latency viewing */
    enableWebRTC?: boolean;
    /** Optional video configuration settings */
    video?: VideoConfig;
    /** Optional audio configuration settings */
    audio?: AudioConfig;
    /** Optional stream configuration settings */
    stream?: StreamConfig;
    /** Optional RTMP destinations to re-stream to (YouTube, Twitch, etc) */
    restreamDestinations?: RestreamDestination[];
}
/**
 * Result returned when starting a managed stream
 */
export interface ManagedStreamResult {
    /** HLS URL for viewing the stream */
    hlsUrl: string;
    /** DASH URL for viewing the stream */
    dashUrl: string;
    /** WebRTC URL if enabled */
    webrtcUrl?: string;
    /** Cloudflare Stream player/preview URL for embedding */
    previewUrl?: string;
    /** Thumbnail image URL */
    thumbnailUrl?: string;
    /** Internal stream ID */
    streamId: string;
}
/**
 * üìπ Managed Streaming Extension for Camera Module
 *
 * Provides managed streaming capabilities where the cloud handles
 * RTMP endpoints and returns HLS/DASH URLs for viewing.
 *
 * @example
 * ```typescript
 * // Start a managed stream
 * const urls = await session.camera.startManagedStream({
 *   quality: '720p',
 *   enableWebRTC: true
 * });
 * console.log('HLS URL:', urls.hlsUrl);
 * console.log('DASH URL:', urls.dashUrl);
 * console.log('Player URL:', urls.previewUrl);
 * console.log('Thumbnail:', urls.thumbnailUrl);
 *
 * // Monitor managed stream status
 * session.camera.onManagedStreamStatus((status) => {
 *   console.log('Managed stream status:', status.status);
 * });
 *
 * // Stop managed stream
 * await session.camera.stopManagedStream();
 * ```
 */
export declare class CameraManagedExtension {
    private send;
    private packageName;
    private sessionId;
    private logger;
    private session?;
    private isManagedStreaming;
    private currentManagedStreamId?;
    private currentManagedStreamUrls?;
    private managedStreamStatus?;
    private pendingStreamChecks?;
    private pendingManagedStreamRequest?;
    constructor(packageName: string, sessionId: string, send: (message: any) => void, logger: Logger, session?: any);
    /**
     * üìπ Start a managed stream
     *
     * The cloud will handle the RTMP endpoint and return HLS/DASH URLs for viewing.
     * Multiple apps can consume the same managed stream simultaneously.
     *
     * @param options - Configuration options for the managed stream
     * @returns Promise that resolves with viewing URLs when the stream is ready
     *
     * @example
     * ```typescript
     * const urls = await session.camera.startManagedStream({
     *   quality: '1080p',
     *   enableWebRTC: true,
     *   video: { fps: 30 },
     *   audio: { sampleRate: 48000 }
     * });
     *
     * // Access all available URLs
     * console.log('HLS URL:', urls.hlsUrl);
     * console.log('DASH URL:', urls.dashUrl);
     * console.log('Player URL:', urls.previewUrl);  // Embeddable player
     * console.log('Thumbnail:', urls.thumbnailUrl);
     * ```
     */
    startManagedStream(options?: ManagedStreamOptions): Promise<ManagedStreamResult>;
    /**
     * üõë Stop the current managed stream
     *
     * This will stop streaming for this app only. If other apps are consuming
     * the same managed stream, it will continue for them.
     *
     * @returns Promise that resolves when the stop request is sent
     */
    stopManagedStream(): Promise<void>;
    /**
     * üîç Check for any existing streams (managed or unmanaged) for the current user
     *
     * @returns Promise that resolves with stream information if a stream exists
     *
     * @example
     * ```typescript
     * const streamInfo = await session.camera.checkExistingStream();
     * if (streamInfo.hasActiveStream) {
     *   console.log('Stream type:', streamInfo.streamInfo?.type);
     *   if (streamInfo.streamInfo?.type === 'managed') {
     *     console.log('HLS URL:', streamInfo.streamInfo.hlsUrl);
     *   }
     * }
     * ```
     */
    checkExistingStream(): Promise<{
        hasActiveStream: boolean;
        streamInfo?: {
            type: "managed" | "unmanaged";
            streamId: string;
            status: string;
            createdAt: Date;
            hlsUrl?: string;
            dashUrl?: string;
            webrtcUrl?: string;
            previewUrl?: string;
            thumbnailUrl?: string;
            activeViewers?: number;
            rtmpUrl?: string;
            requestingAppId?: string;
        };
    }>;
    /**
     * üìä Check if currently managed streaming
     *
     * @returns true if a managed stream is active
     */
    isManagedStreamActive(): boolean;
    /**
     * üîó Get current managed stream URLs
     *
     * @returns Current stream URLs or undefined if not streaming
     */
    getManagedStreamUrls(): ManagedStreamResult | undefined;
    /**
     * üìä Get current managed stream status
     *
     * @returns Current stream status or undefined
     */
    getManagedStreamStatus(): ManagedStreamStatus | undefined;
    /**
     * üîî Register a handler for managed stream status updates
     *
     * @param handler - Function to call when stream status changes
     * @returns Cleanup function to unregister the handler
     *
     * @example
     * ```typescript
     * const cleanup = session.camera.onManagedStreamStatus((status) => {
     *   console.log('Status:', status.status);
     *   if (status.status === 'active') {
     *     console.log('Stream is live!');
     *   }
     * });
     *
     * // Later, unregister the handler
     * cleanup();
     * ```
     */
    onManagedStreamStatus(handler: (status: ManagedStreamStatus) => void): () => void;
    /**
     * Handle incoming stream status check response
     * Called by the parent AppSession when a response is received
     */
    handleStreamCheckResponse(response: StreamStatusCheckResponse): void;
    /**
     * Handle incoming managed stream status messages
     * Called by the parent AppSession when messages are received
     */
    handleManagedStreamStatus(status: ManagedStreamStatus): void;
    /**
     * üßπ Clean up all managed streaming state
     */
    cleanup(): void;
}
//# sourceMappingURL=camera-managed-extension.d.ts.map