"use strict";
/**
 * üì∑ Camera Module
 *
 * Unified camera functionality for App Sessions.
 * Handles both photo requests and RTMP streaming from connected glasses.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CameraModule = void 0;
const types_1 = require("../../../types");
const streams_1 = require("../../../types/streams");
const camera_managed_extension_1 = require("./camera-managed-extension");
/**
 * üì∑ Camera Module Implementation
 *
 * Unified camera management for App Sessions.
 * Provides methods for:
 * - üì∏ Requesting photos from glasses
 * - üìπ Starting/stopping RTMP streams
 * - üîç Monitoring photo and stream status
 * - üßπ Cleanup and cancellation
 *
 * @example
 * ```typescript
 * // Request a photo
 * const photoData = await session.camera.requestPhoto({ saveToGallery: true });
 *
 * // Start streaming
 * await session.camera.startStream({ rtmpUrl: 'rtmp://example.com/live/key' });
 *
 * // Monitor stream status
 * session.camera.onStreamStatus((status) => {
 *   console.log('Stream status:', status.status);
 * });
 *
 * // Stop streaming
 * await session.camera.stopStream();
 * ```
 */
class CameraModule {
    /**
     * Create a new CameraModule
     *
     * @param packageName - The App package name
     * @param sessionId - The current session ID
     * @param send - Function to send messages to the cloud
     * @param session - Reference to the parent AppSession (optional)
     * @param logger - Logger instance for debugging
     */
    constructor(packageName, sessionId, send, session, logger) {
        // Photo functionality
        /** Map to store pending photo request promises */
        this.pendingPhotoRequests = new Map();
        // Streaming functionality
        this.isStreaming = false;
        this.packageName = packageName;
        this.sessionId = sessionId;
        this.send = send;
        this.session = session;
        this.logger = logger || console;
        // Initialize managed extension
        this.managedExtension = new camera_managed_extension_1.CameraManagedExtension(packageName, sessionId, send, this.logger, session);
    }
    // =====================================
    // üì∏ Photo Functionality
    // =====================================
    /**
     * üì∏ Request a photo from the connected glasses
     *
     * @param options - Optional configuration for the photo request
     * @returns Promise that resolves with the actual photo data
     *
     * @example
     * ```typescript
     * // Request a photo
     * const photo = await session.camera.requestPhoto();
     *
     * // Request a photo with custom webhook URL
     * const photo = await session.camera.requestPhoto({
     *   customWebhookUrl: 'https://my-custom-endpoint.com/photo-upload'
     * });
     * ```
     */
    async requestPhoto(options) {
        return new Promise((resolve, reject) => {
            try {
                // Generate unique request ID
                const requestId = `photo_req_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
                // Store promise resolvers for when we get the response
                this.pendingPhotoRequests.set(requestId, { resolve, reject });
                // Create photo request message
                const message = {
                    type: types_1.AppToCloudMessageType.PHOTO_REQUEST,
                    packageName: this.packageName,
                    sessionId: this.sessionId,
                    requestId,
                    timestamp: new Date(),
                    saveToGallery: options?.saveToGallery || false,
                    customWebhookUrl: options?.customWebhookUrl,
                    size: options?.size || "medium",
                };
                // Send request to cloud
                this.send(message);
                this.logger.info({
                    requestId,
                    saveToGallery: options?.saveToGallery,
                    hasCustomWebhook: !!options?.customWebhookUrl,
                }, `üì∏ Photo request sent`);
                // If using custom webhook URL, resolve immediately since photo will be uploaded directly to custom endpoint
                if (options?.customWebhookUrl) {
                    this.logger.info({ requestId, customWebhookUrl: options.customWebhookUrl }, `üì∏ Using custom webhook URL - resolving promise immediately since photo will be uploaded directly to custom endpoint`);
                    // Create a mock PhotoData object for custom webhook URLs
                    const mockPhotoData = {
                        buffer: Buffer.from([]), // Empty buffer since we don't have the actual photo
                        mimeType: "image/jpeg",
                        filename: "photo.jpg",
                        requestId,
                        size: 0,
                        timestamp: new Date(),
                    };
                    // Resolve immediately and clean up
                    this.pendingPhotoRequests.delete(requestId);
                    resolve(mockPhotoData);
                    return;
                }
                // Set timeout to avoid hanging promises (only for non-custom webhook requests)
                const timeoutMs = 30000; // 30 seconds
                if (this.session && this.session.resources) {
                    // Use session's resource tracker for automatic cleanup
                    this.session.resources.setTimeout(() => {
                        if (this.pendingPhotoRequests.has(requestId)) {
                            this.pendingPhotoRequests
                                .get(requestId)
                                .reject("Photo request timed out");
                            this.pendingPhotoRequests.delete(requestId);
                            this.logger.warn({ requestId }, `üì∏ Photo request timed out`);
                        }
                    }, timeoutMs);
                }
                else {
                    // Fallback to regular setTimeout if session not available
                    setTimeout(() => {
                        if (this.pendingPhotoRequests.has(requestId)) {
                            this.pendingPhotoRequests
                                .get(requestId)
                                .reject("Photo request timed out");
                            this.pendingPhotoRequests.delete(requestId);
                            this.logger.warn({ requestId }, `üì∏ Photo request timed out`);
                        }
                    }, timeoutMs);
                }
            }
            catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                reject(`Failed to request photo: ${errorMessage}`);
            }
        });
    }
    /**
     * üì• Handle photo received from /photo-upload endpoint
     *
     * This method is called internally when a photo response is received.
     * It resolves the corresponding pending promise with the photo data.
     *
     * @param photoData - The photo data received
     * @internal This method is used internally by AppSession
     */
    handlePhotoReceived(photoData) {
        const { requestId } = photoData;
        const pendingRequest = this.pendingPhotoRequests.get(requestId);
        if (pendingRequest) {
            this.logger.info({ requestId }, `üì∏ Photo received for request ${requestId}`);
            // Resolve the promise with the photo data
            pendingRequest.resolve(photoData);
            // Clean up
            this.pendingPhotoRequests.delete(requestId);
        }
        else {
            this.logger.warn({ requestId }, `üì∏ Received photo for unknown request ID: ${requestId}`);
        }
    }
    /**
     * üîç Check if there's a pending photo request for the given request ID
     *
     * @param requestId - The request ID to check
     * @returns true if there's a pending request
     */
    hasPhotoPendingRequest(requestId) {
        return this.pendingPhotoRequests.has(requestId);
    }
    /**
     * üìä Get the number of pending photo requests
     *
     * @returns Number of pending photo requests
     */
    getPhotoPendingRequestCount() {
        return this.pendingPhotoRequests.size;
    }
    /**
     * üìã Get all pending photo request IDs
     *
     * @returns Array of pending request IDs
     */
    getPhotoPendingRequestIds() {
        return Array.from(this.pendingPhotoRequests.keys());
    }
    /**
     * ‚ùå Cancel a pending photo request
     *
     * @param requestId - The request ID to cancel
     * @returns true if the request was cancelled, false if it wasn't found
     */
    cancelPhotoRequest(requestId) {
        const pendingRequest = this.pendingPhotoRequests.get(requestId);
        if (pendingRequest) {
            pendingRequest.reject("Photo request cancelled");
            this.pendingPhotoRequests.delete(requestId);
            this.logger.info({ requestId }, `üì∏ Photo request cancelled`);
            return true;
        }
        return false;
    }
    /**
     * üßπ Cancel all pending photo requests
     *
     * @returns Number of requests that were cancelled
     */
    cancelAllPhotoRequests() {
        const count = this.pendingPhotoRequests.size;
        for (const [requestId, { reject }] of this.pendingPhotoRequests) {
            reject("Photo request cancelled - session cleanup");
            this.logger.info({ requestId }, `üì∏ Photo request cancelled during cleanup`);
        }
        this.pendingPhotoRequests.clear();
        return count;
    }
    // =====================================
    // üìπ Streaming Functionality
    // =====================================
    /**
     * üìπ Start an RTMP stream to the specified URL
     *
     * @param options - Configuration options for the stream
     * @returns Promise that resolves when the stream request is sent (not when streaming begins)
     *
     * @example
     * ```typescript
     * await session.camera.startStream({
     *   rtmpUrl: 'rtmp://live.example.com/stream/key',
     *   video: { resolution: '1920x1080', bitrate: 5000 },
     *   audio: { bitrate: 128 }
     * });
     * ```
     */
    async startStream(options) {
        this.logger.info({ rtmpUrl: options.rtmpUrl }, `üìπ RTMP stream request starting`);
        if (!options.rtmpUrl) {
            throw new Error("rtmpUrl is required");
        }
        if (this.isStreaming) {
            this.logger.error({
                currentStreamUrl: this.currentStreamUrl,
                requestedUrl: options.rtmpUrl,
            }, `üìπ Already streaming error`);
            throw new Error("Already streaming. Stop the current stream before starting a new one.");
        }
        // Create stream request message
        const message = {
            type: types_1.AppToCloudMessageType.RTMP_STREAM_REQUEST,
            packageName: this.packageName,
            sessionId: this.sessionId,
            rtmpUrl: options.rtmpUrl,
            video: options.video,
            audio: options.audio,
            stream: options.stream,
            timestamp: new Date(),
        };
        // Save stream URL for reference
        this.currentStreamUrl = options.rtmpUrl;
        // Send the request
        try {
            this.send(message);
            this.isStreaming = true;
            this.logger.info({ rtmpUrl: options.rtmpUrl }, `üìπ RTMP stream request sent successfully`);
            return Promise.resolve();
        }
        catch (error) {
            this.logger.error({ error, rtmpUrl: options.rtmpUrl }, `üìπ Failed to send RTMP stream request`);
            const errorMessage = error instanceof Error ? error.message : String(error);
            return Promise.reject(`Failed to request RTMP stream: ${errorMessage}`);
        }
    }
    /**
     * üõë Stop the current RTMP stream
     *
     * @returns Promise that resolves when the stop request is sent
     *
     * @example
     * ```typescript
     * await session.camera.stopStream();
     * ```
     */
    async stopStream() {
        this.logger.info({
            isCurrentlyStreaming: this.isStreaming,
            currentStreamUrl: this.currentStreamUrl,
        }, `üìπ RTMP stream stop request`);
        if (!this.isStreaming) {
            this.logger.info(`üìπ Not streaming - no-op`);
            // Not an error - just a no-op if not streaming
            return Promise.resolve();
        }
        // Create stop request message
        const message = {
            type: types_1.AppToCloudMessageType.RTMP_STREAM_STOP,
            packageName: this.packageName,
            sessionId: this.sessionId,
            streamId: this.currentStreamState?.streamId, // Include streamId if available
            timestamp: new Date(),
        };
        // Send the request
        try {
            this.send(message);
            return Promise.resolve();
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            return Promise.reject(`Failed to stop RTMP stream: ${errorMessage}`);
        }
    }
    /**
     * üîç Check if currently streaming
     *
     * @returns True if a stream is active or initializing
     */
    isCurrentlyStreaming() {
        return this.isStreaming;
    }
    /**
     * üìç Get the URL of the current stream (if any)
     *
     * @returns The RTMP URL of the current stream, or undefined if not streaming
     */
    getCurrentStreamUrl() {
        return this.currentStreamUrl;
    }
    /**
     * üìä Get the current stream status
     *
     * @returns The current stream status, or undefined if not available
     */
    getStreamStatus() {
        return this.currentStreamState;
    }
    /**
     * üì∫ Subscribe to RTMP stream status updates
     * This uses the standard stream subscription mechanism
     */
    subscribeToStreamStatusUpdates() {
        if (this.session) {
            this.session.subscribe(streams_1.StreamType.RTMP_STREAM_STATUS);
        }
        else {
            this.logger.error("Cannot subscribe to status updates: session reference not available");
        }
    }
    /**
     * üì∫ Unsubscribe from RTMP stream status updates
     */
    unsubscribeFromStreamStatusUpdates() {
        if (this.session) {
            this.session.unsubscribe(streams_1.StreamType.RTMP_STREAM_STATUS);
        }
    }
    /**
     * üëÇ Listen for stream status updates using the standard event system
     * @param handler - Function to call when stream status changes
     * @returns Cleanup function to remove the handler
     *
     * @example
     * ```typescript
     * const cleanup = session.camera.onStreamStatus((status) => {
     *   console.log('Stream status:', status.status);
     *   if (status.status === 'error') {
     *     console.error('Stream error:', status.errorDetails);
     *   }
     * });
     *
     * // Later, cleanup the listener
     * cleanup();
     * ```
     */
    onStreamStatus(handler) {
        if (!this.session) {
            this.logger.error("Cannot listen for status updates: session reference not available");
            return () => { };
        }
        this.subscribeToStreamStatusUpdates();
        return this.session.on(streams_1.StreamType.RTMP_STREAM_STATUS, handler);
    }
    /**
     * üîÑ Update internal stream state based on a status message
     * For internal use by AppSession
     * @param message - The status message from the cloud
     * @internal This method is used internally by AppSession
     */
    updateStreamState(message) {
        this.logger.debug({
            messageType: message?.type,
            messageStatus: message?.status,
            currentIsStreaming: this.isStreaming,
        }, `üìπ Stream state update`);
        // Verify this is a valid stream response
        if (!(0, types_1.isRtmpStreamStatus)(message)) {
            this.logger.warn({ message }, `üìπ Received invalid stream status message`);
            return;
        }
        // Convert to StreamStatus format
        const status = {
            type: message.type,
            streamId: message.streamId,
            status: message.status,
            errorDetails: message.errorDetails,
            appId: message.appId,
            stats: message.stats,
            timestamp: message.timestamp || new Date(),
        };
        this.logger.info({
            streamId: status.streamId,
            oldStatus: this.currentStreamState?.status,
            newStatus: status.status,
            wasStreaming: this.isStreaming,
        }, `üìπ Stream status processed`);
        // Update local state based on status
        if (status.status === "stopped" ||
            status.status === "error" ||
            status.status === "timeout") {
            this.logger.info({
                status: status.status,
                wasStreaming: this.isStreaming,
            }, `üìπ Stream stopped - updating local state`);
            this.isStreaming = false;
            this.currentStreamUrl = undefined;
        }
        // Save the latest status
        this.currentStreamState = status;
    }
    // =====================================
    // üìπ Managed Streaming Functionality
    // =====================================
    /**
     * üìπ Start a managed stream
     *
     * The cloud handles the RTMP endpoint and returns HLS/DASH URLs for viewing.
     * Multiple apps can consume the same managed stream simultaneously.
     *
     * @param options - Configuration options for the managed stream
     * @returns Promise that resolves with viewing URLs when the stream is ready
     *
     * @example
     * ```typescript
     * const urls = await session.camera.startManagedStream({
     *   quality: '720p',
     *   enableWebRTC: true
     * });
     * console.log('HLS URL:', urls.hlsUrl);
     * ```
     */
    async startManagedStream(options) {
        return this.managedExtension.startManagedStream(options);
    }
    /**
     * üõë Stop the current managed stream
     *
     * This will stop streaming for this app only. If other apps are consuming
     * the same managed stream, it will continue for them.
     *
     * @returns Promise that resolves when the stop request is sent
     */
    async stopManagedStream() {
        return this.managedExtension.stopManagedStream();
    }
    /**
     * üîî Register a handler for managed stream status updates
     *
     * @param handler - Function to call when stream status changes
     * @returns Cleanup function to unregister the handler
     */
    onManagedStreamStatus(handler) {
        return this.managedExtension.onManagedStreamStatus(handler);
    }
    /**
     * üìä Check if currently managed streaming
     *
     * @returns true if a managed stream is active
     */
    isManagedStreamActive() {
        return this.managedExtension.isManagedStreamActive();
    }
    /**
     * üîó Get current managed stream URLs
     *
     * @returns Current stream URLs or undefined if not streaming
     */
    getManagedStreamUrls() {
        return this.managedExtension.getManagedStreamUrls();
    }
    /**
     * üîç Check for any existing streams (managed or unmanaged) for the current user
     *
     * This method checks if there's already an active stream for the current user,
     * which is useful to avoid conflicts and to reconnect to existing streams.
     *
     * @returns Promise that resolves with stream information if a stream exists
     *
     * @example
     * ```typescript
     * const streamInfo = await session.camera.checkExistingStream();
     * if (streamInfo.hasActiveStream) {
     *   console.log('Stream type:', streamInfo.streamInfo?.type);
     *   if (streamInfo.streamInfo?.type === 'managed') {
     *     console.log('HLS URL:', streamInfo.streamInfo.hlsUrl);
     *   } else {
     *     console.log('RTMP URL:', streamInfo.streamInfo.rtmpUrl);
     *   }
     * }
     * ```
     */
    async checkExistingStream() {
        return this.managedExtension.checkExistingStream();
    }
    /**
     * Handle incoming stream status check response
     * @internal
     */
    handleStreamCheckResponse(response) {
        this.managedExtension.handleStreamCheckResponse(response);
    }
    /**
     * Handle incoming managed stream status messages
     * @internal
     */
    handleManagedStreamStatus(message) {
        this.managedExtension.handleManagedStreamStatus(message);
    }
    // =====================================
    // üîß General Utilities
    // =====================================
    /**
     * üîß Update the session ID (used when reconnecting)
     *
     * @param newSessionId - The new session ID
     * @internal This method is used internally by AppSession
     */
    updateSessionId(newSessionId) {
        this.sessionId = newSessionId;
    }
    /**
     * üßπ Cancel all pending requests and clean up resources
     *
     * @returns Object with counts of cancelled requests
     */
    cancelAllRequests() {
        const photoRequests = this.cancelAllPhotoRequests();
        // Stop streaming if active
        if (this.isStreaming) {
            this.stopStream().catch((error) => {
                this.logger.error({ error }, "Error stopping stream during cleanup");
            });
        }
        // Clean up managed extension
        this.managedExtension.cleanup();
        return { photoRequests };
    }
}
exports.CameraModule = CameraModule;
